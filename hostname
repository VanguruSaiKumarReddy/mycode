#!/usr/bin/env bash
set -euo pipefail

# Supported: Amazon Linux 2 / 2023, Ubuntu 22.04 / 24.04, RHEL 9
# Behavior:
# - Uses AWS CLI ONLY to fetch the tag (default key: Name; override with TAG_KEY env var)
# - Sanitizes to RFC-952/1123; sets via hostnamectl; updates /etc/hostname and /etc/hosts idempotently.

TAG_KEY="${TAG_KEY:-Name}"

need_root() {
  if [[ $EUID -ne 0 ]]; then
    echo "This script must run as root (use sudo)." >&2
    exit 1
  fi
}

require_cli() {
  if ! command -v aws >/dev/null 2>&1; then
    echo "aws CLI not found. Install it and retry." >&2
    # quick hints per family
    if [[ -f /etc/os-release ]]; then
      . /etc/os-release
      case "$ID:$VERSION_ID" in
        amzn:2|amzn:2023) echo "Hint: sudo yum install -y awscli" >&2 ;;
        ubuntu:22.04|ubuntu:24.04) echo "Hint: sudo apt-get update && sudo apt-get install -y awscli" >&2 ;;
        rhel:9*) echo "Hint: sudo dnf install -y awscli" >&2 ;;
      esac
    fi
    exit 2
  fi
}

log() { echo "[hostname-sync] $*"; }

imds_get() {
  # IMDS used only for instance-id and region (safe even with tags disabled)
  local path="$1"
  # Use token if IMDSv2 is enforced
  local token=""
  token="$(curl -sS -m 2 -X PUT "http://169.254.169.254/latest/api/token" \
           -H "X-aws-ec2-metadata-token-ttl-seconds: 300" || true)"
  if [[ -n "$token" ]]; then
    curl -sS -m 2 -H "X-aws-ec2-metadata-token: $token" "http://169.254.169.254/${path}"
  else
    curl -sS -m 2 "http://169.254.169.254/${path}"
  fi
}

sanitize_hostname() {
  # Lowercase, spaces/underscores -> hyphen, strip invalids, trim ends, collapse dashes, max 63 chars
  local raw="$1" s
  s="$(echo -n "$raw" | tr '[:upper:]' '[:lower:]' | sed -E 's/[ _]+/-/g')"
  s="$(echo -n "$s" | sed -E 's/[^a-z0-9-]+/-/g')"
  s="$(echo -n "$s" | sed -E 's/^-+//; s/-+$//')"
  s="$(echo -n "$s" | sed -E 's/-{2,}/-/g')"
  s="${s:0:63}"
  [[ -z "$s" ]] && s="ec2-host"
  [[ "$s" =~ ^- ]] && s="ec2${s}"
  [[ "$s" =~ -$ ]] && s="${s%-}"
  echo -n "$s"
}

detect_distro() {
  . /etc/os-release
  case "${ID:-}:${VERSION_ID:-}" in
    amzn:2|amzn:2023) DISTRO="amazon" ;;
    ubuntu:22.04|ubuntu:24.04) DISTRO="ubuntu" ;;
    rhel:9*|redhat:9*|rocky:9*|almalinux:9*) DISTRO="rhel" ;;
    *) DISTRO="unknown" ;;
  esac
}

update_hosts() {
  local new="$1"
  local hosts="/etc/hosts"
  local loop="127.0.0.1"
  [[ "$DISTRO" == "ubuntu" ]] && loop="127.0.1.1"   # ubuntu prefers 127.0.1.1 mapping

  touch "$hosts"
  # Remove prior managed lines
  sed -i -E '/# managed by hostname-sync/d' "$hosts" || true
  sed -i -E "/127\.0\.[01]\.1[[:space:]]+[a-z0-9-]+[[:space:]]+# managed by hostname-sync/d" "$hosts" || true

  # Add our mapping
  echo "$loop   $new # managed by hostname-sync" >> "$hosts"

  # Ensure localhost exists
  grep -qE '(^|[[:space:]])localhost([[:space:]]|$)' "$hosts" || echo "127.0.0.1   localhost" >> "$hosts"
}

apply_hostname() {
  local new="$1"
  if command -v hostnamectl >/dev/null 2>&1; then
    if [[ "$(hostname -s)" != "$new" ]]; then
      hostnamectl set-hostname "$new"
    fi
  else
    hostname "$new" || true
  fi
  echo "$new" > /etc/hostname
  update_hosts "$new"
}

main() {
  need_root
  require_cli
  detect_distro

  INSTANCE_ID="$(imds_get 'latest/meta-data/instance-id' || true)"
  REGION="$(imds_get 'latest/dynamic/instance-identity/document' | awk -F\" '/region/ {print $4}')"

  if [[ -z "${INSTANCE_ID:-}" || -z "${REGION:-}" ]]; then
    echo "ERROR: Could not read instance-id/region from IMDS." >&2
    exit 3
  fi

  # Pull the tag strictly via AWS CLI
  INSTANCE_NAME="$(aws ec2 describe-tags \
      --region "$REGION" \
      --filters "Name=resource-id,Values=${INSTANCE_ID}" "Name=key,Values=${TAG_KEY}" \
      --query "Tags[0].Value" --output text 2>/dev/null || true)"
  [[ "$INSTANCE_NAME" == "None" ]] && INSTANCE_NAME=""

  if [[ -z "$INSTANCE_NAME" ]]; then
    echo "ERROR: Tag '${TAG_KEY}' not found or not allowed. Ensure instance role has ec2:DescribeTags." >&2
    exit 4
  fi

  NEW_HOSTNAME="$(sanitize_hostname "$INSTANCE_NAME")"
  if [[ -z "$NEW_HOSTNAME" ]]; then
    echo "ERROR: Sanitized hostname is empty." >&2
    exit 5
  fi

  CUR="$(hostname -s || true)"
  if [[ "$CUR" == "$NEW_HOSTNAME" ]]; then
    log "No change needed. Hostname already '$NEW_HOSTNAME'."
    exit 0
  fi

  apply_hostname "$NEW_HOSTNAME"
  log "Final hostname: $(hostname -f || hostname -s)"
}

main "$@"
