#!/usr/bin/env bash
set -euo pipefail

# =========================
# Config (override via env)
# =========================
ROLE_NAME="${ROLE_NAME:-TFC.RL.AWS.Enterprise.BootStrapAuto}"   # role in each member account
PROFILE="${PROFILE:-default}"                                   # local CLI profile for STS
REGIONS=(${REGIONS:-"us-east-1" "us-east-2" "us-west-2"})
ACCOUNTS_FILE="${ACCOUNTS_FILE:-accounts.txt}"                  # one account ID per line (# comments ok)

# The local script you want to run on instances
SCRIPT_PATH="${SCRIPT_PATH:-payload.sh}"                        # set to your file
SCRIPT_ARGS="${SCRIPT_ARGS:-}"                                   # optional args passed to the script

# Fan-out safety knobs
MAX_CONCURRENCY="${MAX_CONCURRENCY:-50%}"                       # e.g., "100" or "50%"
MAX_ERRORS="${MAX_ERRORS:-10%}"                                  # e.g., "20" or "10%"
BATCH_SIZE="${BATCH_SIZE:-50}"                                   # API limit is 50 instance-ids per call

# Optional: capture stdout/stderr to S3
OUTPUT_S3_BUCKET="${OUTPUT_S3_BUCKET:-}"                        # e.g., my-ops-logs
OUTPUT_S3_PREFIX="${OUTPUT_S3_PREFIX:-ssm/linux}"               # e.g., ssm/runs/$(date +%F)
OUTPUT_S3_KMS_KEY_ID="${OUTPUT_S3_KMS_KEY_ID:-}"                # optional SSE-KMS

# =========================
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing: $1"; exit 1; }; }
need aws; need jq; need base64

[[ -f "$SCRIPT_PATH" ]] || { echo "SCRIPT_PATH not found: $SCRIPT_PATH"; exit 1; }

# Read and base64-encode your script once (safe transport)
SCRIPT_B64="$(base64 -w0 "$SCRIPT_PATH")"

# Build the command that reconstructs & runs your script on the target
# - writes /tmp/payload.sh, chmod +x, executes with optional args
REMOTE_CMD="set -euo pipefail; echo '$SCRIPT_B64' | base64 -d > /tmp/payload.sh; chmod +x /tmp/payload.sh; sudo /bin/bash /tmp/payload.sh ${SCRIPT_ARGS}"

# Globals set by assume_role()
AK=""; SK=""; ST=""

assume_role() {
  local account_id="$1"
  local sts_region="us-east-1"
  local creds
  creds=$(aws sts assume-role \
    --region "$sts_region" \
    --role-arn "arn:aws:iam::${account_id}:role/${ROLE_NAME}" \
    --role-session-name "ssm-fanout-$(date +%s)" \
    --profile "$PROFILE" \
    --query 'Credentials' \
    --output json) || { echo "ASSUME-ROLE FAILED: $account_id"; return 1; }
  AK="$(jq -r '.AccessKeyId'     <<<"$creds")"
  SK="$(jq -r '.SecretAccessKey' <<<"$creds")"
  ST="$(jq -r '.SessionToken'    <<<"$creds")"
}

# List SSM-managed instances that are Linux, Online, EC2Instance, and NOT AL2023
list_linux_online_instances() {
  local region="$1"
  local next_token=""
  local ids=()
  while : ; do
    local args=(
      ssm describe-instance-information
      --region "$region"
      --filters "Key=PlatformTypes,Values=Linux" "Key=PingStatus,Values=Online" "Key=ResourceType,Values=EC2Instance"
      --max-results 50
      --output json
    )
    [[ -n "$next_token" ]] && args+=( --next-token "$next_token" )
    local page
    page=$(AWS_ACCESS_KEY_ID="$AK" AWS_SECRET_ACCESS_KEY="$SK" AWS_SESSION_TOKEN="$ST" aws "${args[@]}")
    mapfile -t page_ids < <(
      jq -r '
        .InstanceInformationList[]
        | select( (.PlatformName != "Amazon Linux") or (.PlatformVersion | startswith("2023") | not) )
        | .InstanceId
      ' <<<"$page"
    )
    [[ ${#page_ids[@]} -gt 0 ]] && ids+=("${page_ids[@]}")
    next_token="$(jq -r '.NextToken // empty' <<<"$page")"
    [[ -z "$next_token" ]] && break
  done
  printf "%s\n" "${ids[@]}" | awk 'NF'
}

# Keep only EC2 instances that are in state "running"
filter_running_instances() {
  local region="$1"; shift
  local -a in_ids=( "$@" )
  [[ ${#in_ids[@]} -eq 0 ]] && return 0
  local out=()
  local chunk_size=100
  local i=0
  while (( i < ${#in_ids[@]} )); do
    local chunk=( "${in_ids[@]:i:chunk_size}" )
    local lines
    lines=$(AWS_ACCESS_KEY_ID="$AK" AWS_SECRET_ACCESS_KEY="$SK" AWS_SESSION_TOKEN="$ST" \
      aws ec2 describe-instances --region "$region" --instance-ids "${chunk[@]}" \
      --query 'Reservations[].Instances[?State.Name==`running`].[InstanceId]' \
      --output text 2>/dev/null || true)
    if [[ -n "$lines" ]]; then
      while IFS= read -r id; do [[ -n "$id" ]] && out+=("$id"); done <<<"$lines"
    fi
    i=$(( i + chunk_size ))
  done
  printf "%s\n" "${out[@]}"
}

send_command_batch() {
  local region="$1"; shift
  local -a ids=( "$@" )
  [[ ${#ids[@]} -eq 0 ]] && return 0

  local s3_args=()
  if [[ -n "$OUTPUT_S3_BUCKET" ]]; then
    s3_args+=( --output-s3-bucket-name "$OUTPUT_S3_BUCKET" --output-s3-key-prefix "$OUTPUT_S3_PREFIX" )
    [[ -n "$OUTPUT_S3_KMS_KEY_ID" ]] && s3_args+=( --output-s3-region "$region" --output-s3-encryption-kms-key-id "$OUTPUT_S3_KMS_KEY_ID" )
  fi

  AWS_ACCESS_KEY_ID="$AK" AWS_SECRET_ACCESS_KEY="$SK" AWS_SESSION_TOKEN="$ST" \
  aws ssm send-command \
    --region "$region" \
    --document-name "AWS-RunShellScript" \
    --comment "Fanout script run (Linux-only, excludes AL2023, running instances only)" \
    --parameters "commands=['${REMOTE_CMD//\'/\'\\\'\'}']" \
    --max-concurrency "$MAX_CONCURRENCY" \
    --max-errors "$MAX_ERRORS" \
    --instance-ids "${ids[@]}" \
    "${s3_args[@]}" \
    >/dev/null
}

echo "Account,Region,DiscoveredLinux,RunningAfterFilter,BatchesSubmitted"

[[ -s "$ACCOUNTS_FILE" ]] || { echo "Accounts file '$ACCOUNTS_FILE' not found or empty"; exit 1; }

while IFS= read -r ACCOUNT_ID; do
  ACCOUNT_ID="$(echo "$ACCOUNT_ID" | awk '{$1=$1};1')"
  [[ -z "$ACCOUNT_ID" || "${ACCOUNT_ID:0:1}" == "#" ]] && continue

  if ! assume_role "$ACCOUNT_ID"; then
    for REGION in "${REGIONS[@]}"; do
      echo "${ACCOUNT_ID},${REGION},ASSUME_FAIL,0,0"
    done
    continue
  fi

  for REGION in "${REGIONS[@]}"; do
    mapfile -t LINUX_IDS < <(list_linux_online_instances "$REGION")
    total="${#LINUX_IDS[@]}"

    mapfile -t RUNNING_IDS < <(filter_running_instances "$REGION" "${LINUX_IDS[@]}")
    running="${#RUNNING_IDS[@]}"

    if (( running == 0 )); then
      echo "${ACCOUNT_ID},${REGION},${total},0,0"
      continue
    fi

    submitted=0
    i=0
    while (( i < running )); do
      chunk=( "${RUNNING_IDS[@]:i:BATCH_SIZE}" )
      send_command_batch "$REGION" "${chunk[@]}"
      submitted=$((submitted + 1))
      i=$((i + BATCH_SIZE))
    done

    echo "${ACCOUNT_ID},${REGION},${total},${running},${submitted}"
  done
done < "$ACCOUNTS_FILE"
