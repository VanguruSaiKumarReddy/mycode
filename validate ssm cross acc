#!/usr/bin/env bash
set -euo pipefail

# =========================
# Config (override via env)
# =========================
ROLE_NAME="${ROLE_NAME:-TFC.RL.AWS.Enterprise.BootStrapAuto}"   # role name in each member account
PROFILE="${PROFILE:-default}"                                   # local AWS CLI profile for STS call
REGIONS=(${REGIONS:-"us-east-1" "us-east-2" "us-west-2"})
ACCOUNTS_FILE="${ACCOUNTS_FILE:-accounts.txt}"                  # one account ID per line (# comments ok)

# Shared SSM Document details
DOC_OWNER="${DOC_OWNER:-925514488322}"                          # <— owner account ID
DOC_NAME="${DOC_NAME:-tfc-ami-factory-Install-EC2InstanceConnect-prod}"  # <— document name
DOC_VERSION="${DOC_VERSION:-\$DEFAULT}"                         # explicit version number or $DEFAULT

# Optional parameters for the doc (JSON string). Example:
# DOC_PARAMETERS='{"commands":["echo hello","uname -a"]}'
DOC_PARAMETERS="${DOC_PARAMETERS:-{}}"

# =========================
# Helpers
# =========================
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1"; exit 1; }; }
need aws; need jq

assume_role() {
  local account_id="$1"
  local sts_region="us-east-1"

  local creds
  if ! creds=$(aws sts assume-role \
      --region "$sts_region" \
      --role-arn "arn:aws:iam::${account_id}:role/${ROLE_NAME}" \
      --role-session-name "ssm-validate-$(date +%s)" \
      --profile "$PROFILE" \
      --query 'Credentials' \
      --output json); then
    echo "ASSUME-ROLE: FAILED account=${account_id}"
    return 1
  fi

  export AWS_ACCESS_KEY_ID
  export AWS_SECRET_ACCESS_KEY
  export AWS_SESSION_TOKEN
  AWS_ACCESS_KEY_ID=$(jq -r '.AccessKeyId' <<<"$creds")
  AWS_SECRET_ACCESS_KEY=$(jq -r '.SecretAccessKey' <<<"$creds")
  AWS_SESSION_TOKEN=$(jq -r '.SessionToken' <<<"$creds")
}

doc_arn_for_region() {
  local region="$1"
  printf "arn:aws:ssm:%s:%s:document/%s" "$region" "$DOC_OWNER" "$DOC_NAME"
}

# Returns "OK" (ARN worked), "OK-NONARN" (bare name worked), or "FAIL: <aws error>"
check_doc_visible() {
  local region="$1"
  local doc_arn; doc_arn="$(doc_arn_for_region "$region")"
  : > .doc_err  # truncate

  # 1) Try by ARN
  if aws ssm describe-document --region "$region" --name "$doc_arn" \
       --query '{Name:Name,Owner:Owner,DocumentType:DocumentType,Status:Status,Default:DefaultVersion,Latest:LatestVersion}' \
       --output json >/dev/null 2>.doc_err; then
    rm -f .doc_err
    echo "OK"
    return 0
  fi

  # 2) Try by bare name
  if aws ssm describe-document --region "$region" --name "$DOC_NAME" \
       --query '{Name:Name,Owner:Owner,DocumentType:DocumentType,Status:Status,Default:DefaultVersion,Latest:LatestVersion}' \
       --output json >/dev/null 2>>.doc_err; then
    rm -f .doc_err
    echo "OK-NONARN"
    return 0
  fi

  # 3) Diagnostic: show whatever matches by name/type (non-fatal)
  aws ssm list-documents --region "$region" \
    --filters Key=Name,Values="$DOC_NAME" Key=DocumentType,Values=Command \
    --max-results 50 --output table 2>>.doc_err || true

  local msg
  msg=$(tr -d '\n' < .doc_err | sed 's/  \+/ /g')
  rm -f .doc_err
  echo "FAIL: $msg"
  return 1
}

# Pick one Linux + Online + EC2Instance and ensure EC2 state == running
pick_one_linux_running_instance() {
  local region="$1"
  local ids
  ids=$(aws ssm describe-instance-information \
          --region "$region" \
          --filters "Key=PlatformTypes,Values=Linux" "Key=PingStatus,Values=Online" "Key=ResourceType,Values=EC2Instance" \
          --max-results 50 \
          --query 'InstanceInformationList[].InstanceId' \
          --output text) || true
  [[ -z "$ids" ]] && return 1

  local first_running
  first_running=$(aws ec2 describe-instances \
                    --region "$region" \
                    --instance-ids $ids \
                    --query 'Reservations[].Instances[?State.Name==`running`].[InstanceId]' \
                    --output text | head -n 1) || true
  [[ -z "$first_running" ]] && return 1
  printf "%s" "$first_running"
}

execute_doc_on_instance() {
  local region="$1"
  local instance_id="$2"
  local doc_arn; doc_arn="$(doc_arn_for_region "$region")"

  echo "$DOC_PARAMETERS" | jq empty >/dev/null 2>&1 || { echo "Invalid DOC_PARAMETERS JSON"; return 1; }

  aws ssm send-command \
      --region "$region" \
      --document-name "$doc_arn" \
      --document-version "$DOC_VERSION" \
      --instance-ids "$instance_id" \
      --parameters "$DOC_PARAMETERS" \
      --comment "SSM doc validation" \
      --max-concurrency "1" \
      --max-errors "1" \
      --query 'Command.CommandId' \
      --output text
}

wait_and_summarize() {
  local region="$1"
  local cmd_id="$2"
  aws ssm list-command-invocations \
    --region "$region" \
    --command-id "$cmd_id" \
    --details \
    --query 'CommandInvocations[].{InstanceId:InstanceId,Status:Status,StatusDetails:StatusDetails,StandardOutputUrl:StandardOutputUrl,StandardErrorUrl:StandardErrorUrl}' \
    --output table
}

usage() {
  cat <<EOF
Usage: $(basename "$0") [--execute]

Without --execute:
  - Assumes role into each account in ACCOUNTS_FILE
  - In each region: verifies SSM document visibility (by ARN, then by name)
  - Prints CSV: Account,Region,AssumeRole,DocVisible,Executed,CommandId

With --execute:
  - Also finds ONE Linux + Online + running instance and executes the document on it
  - Pass parameters via env DOC_PARAMETERS (JSON), e.g.:
      DOC_PARAMETERS='{"commands":["echo hello from SSM","uname -a"]}'

Environment overrides:
  ROLE_NAME, PROFILE, REGIONS, ACCOUNTS_FILE,
  DOC_OWNER, DOC_NAME, DOC_VERSION, DOC_PARAMETERS
EOF
}

# =========================
# Main
# =========================
EXECUTE=0
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then usage; exit 0; fi
if [[ "${1:-}" == "--execute" ]]; then EXECUTE=1; fi

[[ -s "$ACCOUNTS_FILE" ]] || { echo "Accounts file '$ACCOUNTS_FILE' not found or empty"; exit 1; }

echo "Account,Region,AssumeRole,DocVisible,Executed,CommandId"

while IFS= read -r ACCOUNT_ID; do
  ACCOUNT_ID="$(echo "$ACCOUNT_ID" | awk '{$1=$1};1')"
  [[ -z "$ACCOUNT_ID" || "${ACCOUNT_ID:0:1}" == "#" ]] && continue

  if ! assume_role "$ACCOUNT_ID"; then
    for REGION in "${REGIONS[@]}"; do
      echo "${ACCOUNT_ID},${REGION},FAIL,SKIP,SKIP,"
    done
    continue
  fi

  for REGION in "${REGIONS[@]}"; do
    VIS=$(check_doc_visible "$REGION" || true)
    DOC_OK="$VIS"   # "OK", "OK-NONARN", or "FAIL: <error>"
    EXEC="NO"; CMDID=""

    if [[ "$EXECUTE" -eq 1 && "$DOC_OK" == OK* ]]; then
      if inst=$(pick_one_linux_running_instance "$REGION"); then
        if cmd=$(execute_doc_on_instance "$REGION" "$inst"); then
          EXEC="YES"; CMDID="$cmd"
          # Optional: print a quick status table (non-blocking)
          wait_and_summarize "$REGION" "$CMDID" || true
        else
          EXEC="FAIL"
        fi
      else
        EXEC="NO-LINUX-ONLINE"
      fi
    fi

    echo "${ACCOUNT_ID},${REGION},OK,${DOC_OK},${EXEC},${CMDID}"
  done
done < "$ACCOUNTS_FILE"
